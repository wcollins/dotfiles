#!/usr/bin/env bash
# transcribe - audio/video transcription using OpenAI Whisper
# https://github.com/openai/whisper

set -euo pipefail

# configuration
VENV_DIR="$HOME/.transcribe/venv"
DEFAULT_MODEL="turbo"
DEFAULT_FORMAT="txt"

# colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # no color

# logging functions
log() { echo -e "${GREEN}[INFO]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
info() { echo -e "${BLUE}[INFO]${NC} $1"; }

# detect os type
OS=""
case "$(uname -s)" in
    Linux*)     OS="linux";;
    Darwin*)    OS="macos";;
    *)          error "unsupported operating system: $(uname -s)"; exit 1;;
esac

# detect architecture
ARCH=""
case "$(uname -m)" in
    x86_64)     ARCH="amd64";;
    amd64)      ARCH="amd64";;
    aarch64)    ARCH="arm64";;
    arm64)      ARCH="arm64";;
    armv7*)     ARCH="armv7";;
    i386)       ARCH="386";;
    i686)       ARCH="386";;
    *)          error "unsupported architecture: $(uname -m)"; exit 1;;
esac

# usage information
usage() {
    cat << EOF
${GREEN}transcribe${NC} - audio/video transcription using OpenAI Whisper

${BLUE}USAGE:${NC}
    transcribe [OPTIONS] [INPUT_FILE]

${BLUE}OPTIONS:${NC}
    --in <path>        Input audio/video file (default: first media file in current directory)
    --out <path>       Output file path (default: same name as input with appropriate extension)
    --model <size>     Whisper model size (default: turbo)
                       Options: tiny, base, small, medium, large, turbo
    --format <fmt>     Output format (default: txt)
                       Options: txt, srt, vtt, json
    --help, -h         Show this help message

${BLUE}EXAMPLES:${NC}
    # transcribe video.mp4 to video.txt in current directory
    transcribe video.mp4

    # transcribe with specific input and output paths
    transcribe --in /path/to/audio.wav --out /path/to/output.txt

    # use different model and format
    transcribe --in audio.mp3 --model small --format srt

    # first media file in current directory with default settings
    transcribe

${BLUE}MODELS:${NC}
    tiny    - Fastest, least accurate (~1GB VRAM)
    base    - Fast, decent accuracy (~1GB VRAM)
    small   - Good balance (~2GB VRAM)
    medium  - High accuracy (~5GB VRAM)
    large   - Best accuracy (~10GB VRAM)
    turbo   - Optimized for speed with high accuracy (~6GB VRAM, recommended)

${BLUE}FORMATS:${NC}
    txt     - Plain text transcription
    srt     - SubRip subtitle format (with timestamps)
    vtt     - WebVTT subtitle format (with timestamps)
    json    - JSON with word-level timestamps

${BLUE}REQUIREMENTS:${NC}
    - Python 3.8+
    - UV package manager
    - FFmpeg (for video processing)

EOF
}

# check python version
check_python() {
    if ! command -v python3 >/dev/null 2>&1; then
        error "python3 is not installed"
        error "please install python 3.8+ and try again"
        return 1
    fi

    local python_version
    python_version=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))' 2>/dev/null || echo "0.0")
    local major_version minor_version
    major_version=$(echo "$python_version" | cut -d. -f1)
    minor_version=$(echo "$python_version" | cut -d. -f2)

    if [[ "$major_version" -lt 3 ]] || { [[ "$major_version" -eq 3 ]] && [[ "$minor_version" -lt 8 ]]; }; then
        error "python 3.8+ is required. current version: $python_version"
        return 1
    fi

    return 0
}

# check if uv is installed
check_uv() {
    if ! command -v uv >/dev/null 2>&1; then
        warn "uv package manager is not installed"
        echo
        read -p "install uv now? (Y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_uv
        else
            error "uv is required for this script"
            info "install uv from: https://docs.astral.sh/uv/getting-started/installation/"
            exit 1
        fi
    fi
}

# install uv package manager
install_uv() {
    log "installing uv package manager..."

    # check if uv.sh exists in setup scripts
    local uv_script="$(dirname "$(dirname "$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")")")/scripts/setup/uv.sh"

    if [[ -f "$uv_script" ]]; then
        log "found uv.sh installation script, running it..."
        bash "$uv_script"
    else
        # fallback to direct installation
        log "downloading and installing uv..."
        curl -LsSf https://astral.sh/uv/install.sh | sh
    fi

    # source shell configuration to get uv in path
    if [[ -f "$HOME/.cargo/env" ]]; then
        source "$HOME/.cargo/env"
    fi

    # verify installation
    if ! command -v uv >/dev/null 2>&1; then
        error "uv installation failed or not in PATH"
        error "please add $HOME/.cargo/bin to your PATH and run this script again"
        exit 1
    fi

    log "uv installed successfully"
}

# check if ffmpeg is installed
check_ffmpeg() {
    if ! command -v ffmpeg >/dev/null 2>&1; then
        warn "ffmpeg is not installed (required for video processing)"
        echo
        read -p "install ffmpeg now? (Y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            install_ffmpeg
        else
            warn "ffmpeg is required for processing video files"
            warn "audio files may work without it, but video will fail"
        fi
    fi
}

# install ffmpeg based on os
install_ffmpeg() {
    log "installing ffmpeg..."

    case "$OS" in
        macos)
            if command -v brew >/dev/null 2>&1; then
                log "installing ffmpeg via homebrew..."
                brew install ffmpeg
            else
                error "homebrew not found. please install ffmpeg manually"
                info "visit: https://ffmpeg.org/download.html"
                exit 1
            fi
            ;;
        linux)
            if command -v apt-get >/dev/null 2>&1; then
                log "installing ffmpeg via apt..."
                sudo apt-get update
                sudo apt-get install -y ffmpeg
            elif command -v dnf >/dev/null 2>&1; then
                log "installing ffmpeg via dnf..."
                sudo dnf install -y ffmpeg
            elif command -v pacman >/dev/null 2>&1; then
                log "installing ffmpeg via pacman..."
                sudo pacman -S --noconfirm ffmpeg
            else
                error "could not auto-install ffmpeg"
                error "please install ffmpeg manually for your distribution"
                exit 1
            fi
            ;;
    esac

    # verify installation
    if command -v ffmpeg >/dev/null 2>&1; then
        log "ffmpeg installed successfully"
    else
        error "ffmpeg installation failed"
        exit 1
    fi
}

# setup virtual environment and install whisper
setup_whisper() {
    if [[ -d "$VENV_DIR" ]]; then
        # venv exists, check if whisper is installed
        if "$VENV_DIR/bin/python" -c "import whisper" 2>/dev/null; then
            log "whisper virtual environment found at $VENV_DIR"
            return 0
        else
            warn "virtual environment exists but whisper is not installed"
            log "reinstalling whisper..."
        fi
    else
        log "setting up whisper for the first time..."
        log "creating virtual environment at $VENV_DIR..."

        # create parent directory
        mkdir -p "$(dirname "$VENV_DIR")"

        # create venv using uv
        uv venv "$VENV_DIR" --python python3
    fi

    log "installing openai-whisper package..."
    info "this may take a few minutes on first run..."

    # install whisper and dependencies
    uv pip install --python "$VENV_DIR" openai-whisper

    # verify installation
    if "$VENV_DIR/bin/python" -c "import whisper" 2>/dev/null; then
        log "whisper installed successfully"
    else
        error "whisper installation failed"
        exit 1
    fi
}

# find first media file in current directory
find_media_file() {
    local media_extensions=("mp4" "mp3" "wav" "m4a" "flac" "ogg" "avi" "mkv" "mov" "webm" "aac" "wma")

    for ext in "${media_extensions[@]}"; do
        local files
        files=$(find . -maxdepth 1 -type f -iname "*.${ext}" 2>/dev/null | head -1)
        if [[ -n "$files" ]]; then
            echo "$files"
            return 0
        fi
    done

    return 1
}

# validate model name
validate_model() {
    local model="$1"
    local valid_models=("tiny" "base" "small" "medium" "large" "turbo")

    for valid_model in "${valid_models[@]}"; do
        if [[ "$model" == "$valid_model" ]]; then
            return 0
        fi
    done

    return 1
}

# validate format
validate_format() {
    local format="$1"
    local valid_formats=("txt" "srt" "vtt" "json")

    for valid_format in "${valid_formats[@]}"; do
        if [[ "$format" == "$valid_format" ]]; then
            return 0
        fi
    done

    return 1
}

# get output filename based on format
get_output_filename() {
    local input_file="$1"
    local format="$2"
    local basename
    basename=$(basename "$input_file")
    local filename="${basename%.*}"

    echo "${filename}.${format}"
}

# transcribe file
transcribe_file() {
    local input_file="$1"
    local output_file="$2"
    local model="$3"
    local format="$4"

    # validate input file exists
    if [[ ! -f "$input_file" ]]; then
        error "input file not found: $input_file"
        exit 1
    fi

    # check if output file exists
    if [[ -f "$output_file" ]]; then
        warn "output file already exists: $output_file"
        read -p "overwrite? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log "transcription cancelled"
            exit 0
        fi
    fi

    log "transcribing: $(basename "$input_file")"
    info "model: $model"
    info "format: $format"
    info "output: $output_file"
    echo

    # prepare output directory
    local output_dir
    output_dir=$(dirname "$output_file")
    mkdir -p "$output_dir"

    # get just the output directory for whisper (it appends the filename)
    local temp_output_dir
    temp_output_dir=$(mktemp -d)

    # run whisper
    log "processing audio/video file..."
    info "this may take several minutes depending on file size and model..."
    echo

    if "$VENV_DIR/bin/python" -m whisper \
        "$input_file" \
        --model "$model" \
        --output_format "$format" \
        --output_dir "$temp_output_dir" \
        --language auto; then

        # whisper creates output file with original name + extension
        local whisper_output
        whisper_output="$temp_output_dir/$(get_output_filename "$(basename "$input_file")" "$format")"

        if [[ -f "$whisper_output" ]]; then
            # move to desired location
            mv "$whisper_output" "$output_file"
            rm -rf "$temp_output_dir"

            echo
            log "transcription complete!"
            info "output: $output_file"

            # show file size
            if command -v du >/dev/null 2>&1; then
                local file_size
                file_size=$(du -h "$output_file" | cut -f1)
                info "size: $file_size"
            fi

            # show preview for text files
            if [[ "$format" == "txt" ]] && [[ -f "$output_file" ]]; then
                echo
                info "preview (first 5 lines):"
                echo "---"
                head -5 "$output_file"
                echo "---"
            fi
        else
            error "whisper completed but output file not found"
            error "expected: $whisper_output"
            rm -rf "$temp_output_dir"
            exit 1
        fi
    else
        error "transcription failed"
        rm -rf "$temp_output_dir"
        exit 1
    fi
}

# main function
main() {
    # parse arguments
    local input_file=""
    local output_file=""
    local model="$DEFAULT_MODEL"
    local format="$DEFAULT_FORMAT"
    local positional_arg=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --in)
                input_file="$2"
                shift 2
                ;;
            --out)
                output_file="$2"
                shift 2
                ;;
            --model)
                model="$2"
                shift 2
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            -*)
                error "unknown option: $1"
                echo
                usage
                exit 1
                ;;
            *)
                if [[ -z "$positional_arg" ]]; then
                    positional_arg="$1"
                else
                    error "multiple positional arguments not supported"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # if positional arg provided, use it as input file
    if [[ -n "$positional_arg" ]]; then
        if [[ -z "$input_file" ]]; then
            input_file="$positional_arg"
        else
            error "cannot specify both positional argument and --in option"
            exit 1
        fi
    fi

    # validate model
    if ! validate_model "$model"; then
        error "invalid model: $model"
        error "valid models: tiny, base, small, medium, large, turbo"
        exit 1
    fi

    # validate format
    if ! validate_format "$format"; then
        error "invalid format: $format"
        error "valid formats: txt, srt, vtt, json"
        exit 1
    fi

    # determine input file
    if [[ -z "$input_file" ]]; then
        log "no input file specified, searching current directory..."
        if input_file=$(find_media_file); then
            input_file=$(basename "$input_file")
            log "found media file: $input_file"
        else
            error "no media files found in current directory"
            error "please specify input file with --in option"
            exit 1
        fi
    fi

    # convert to absolute path
    input_file=$(realpath "$input_file")

    # determine output file
    if [[ -z "$output_file" ]]; then
        # default: same directory as input, same name, different extension
        local input_dir
        input_dir=$(dirname "$input_file")
        local output_filename
        output_filename=$(get_output_filename "$(basename "$input_file")" "$format")
        output_file="${input_dir}/${output_filename}"
    else
        output_file=$(realpath "$output_file")
    fi

    echo
    log "transcribe - audio/video transcription"
    info "detected system: $OS $ARCH"
    echo

    # check dependencies
    log "checking dependencies..."
    check_python || exit 1
    check_uv
    check_ffmpeg
    echo

    # setup whisper
    setup_whisper
    echo

    # transcribe
    transcribe_file "$input_file" "$output_file" "$model" "$format"
}

# run main function
main "$@"
